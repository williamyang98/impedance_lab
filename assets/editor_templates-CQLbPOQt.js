var wt=Object.defineProperty;var xt=(o,t,e)=>t in o?wt(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var v=(o,t,e)=>xt(o,typeof t!="symbol"?t+"":t,e);import{c as ft,p as U,d as kt,a as ut,j as bt,k as zt,b as E,o as M,f as V,r as X,e as Z,n as pt,u as ot,C as $t,E as St,g as I,t as nt,_ as Ct}from"./index-a3sSa0D5.js";/**
 * @license lucide-vue-next v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Mt=ft("circle-minus",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"M8 12h8",key:"1wcyev"}]]);/**
 * @license lucide-vue-next v0.487.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Et=ft("circle-plus",[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"M8 12h8",key:"1wcyev"}],["path",{d:"M12 8v8",key:"napkw2"}]]);function Wt(o,t,e){var ht,lt,dt;const r={spacings:[],conductors:[],layers:[],total_width:0,total_height:0,x_min:0,x_max:0,y_min:0,y_max:0};function i(h,_){switch(_){case"center":return(h.x_left+h.x_right)/2;case"left":return h.x_left;case"right":return h.x_right}}function s(h,_,g){switch(h){case"left":return{x_left:g,x_right:g+_};case"center":return{x_left:g-_/2,x_right:g+_/2};case"right":return{x_left:g-_,x_right:g}}}const d=o.conductors.filter(h=>h.type=="trace"),c={};for(const h of d)c[h.id]=h;const n=[],u={},l=h=>{n.push(h),u[h.id]=h},f=[],w={},p=(h,_)=>{f.push(_),w[h]=_},m=o.spacings;{e==null||e.begin("trace_layout_horizontal","Layout traces horizontally use widths and spacings");{const g=d[0],y=t(g.width),k={id:g.id,x_left:0,x_right:y};l(k)}let h=0,_=0;for(;!(_>=m.length);){const g=h,y=m[g];h=(h+1)%m.length;const k=y.left_trace.id,z=y.right_trace.id,W=c[k],C=c[z],$=u[k],j=u[z],B=w[g];if(!W)throw Error(`Spacing referenced non existence left trace id ${k}`);if(!C)throw Error(`Spacing referenced non existence right trace id ${z}`);if($===void 0&&j===void 0)_++;else if($===void 0&&j!==void 0){const F=t(y.width),L=t(W.width),et=i(j,y.right_trace.attach),it=et-F,at=s(y.left_trace.attach,L,it);l({id:y.left_trace.id,...at}),p(g,{x_left:it,x_right:et}),_=0}else if($!==void 0&&j===void 0){const F=t(y.width),L=t(C.width),et=i($,y.left_trace.attach),it=et+F,at=s(y.right_trace.attach,L,it);l({id:y.right_trace.id,...at}),p(g,{x_left:et,x_right:it}),_=0}else if($!==void 0&&j!==void 0&&B===void 0){const F=i($,y.left_trace.attach),L=i(j,y.right_trace.attach);p(g,{x_left:F,x_right:L}),_=0}else _++}if(e==null||e.end(),n.length!=d.length)throw Error(`Failed to find x position of all traces. Found ${n.length} but needed ${d.length}`);if(f.length!=m.length)throw Error(`Failed resolve all spacings. Resolved ${f.length} but needed ${m.length}`)}const a=n.reduce((h,_)=>Math.min(h,_.x_left),1/0),x=n.reduce((h,_)=>Math.max(h,_.x_right),0);r.total_width=x-a,r.x_min=a,r.x_max=x,e==null||e.begin("layer_layout_vertical","Layout layers horizontally from heights");const b={},S={};for(const h of o.conductors){const _=h.position.layer_id;{let g=b[_];g===void 0&&(g=new Set,b[_]=g),g.add(h.position.orientation)}if(h.type=="plane"&&((ht=h.layout)==null?void 0:ht.shrink_trace_layer)!==!1){let g=S[_];g===void 0&&(g={},S[_]=g),g[h.position.orientation]=h}}const H=(h,_)=>{const g=b[h];return g===void 0?!1:g.has(_)},P=(h,_)=>{const g=S[h];if(g!==void 0)return g[_]},A={},G={},J={},K=h=>{r.layers.push(h),A[h.parent.id]=h};{let h=0;for(const _ of o.layers)switch(_.type){case"unmasked":{const g=h,y=P(_.id,_.orientation);if(y)h+=t(y.height);else if(H(_.id,_.orientation)){const z=t(_.trace_height);J[_.id]=z;const C=t(_.etch_factor)*z*2;G[_.id]=C,h+=z}K({type:"unmasked",parent:_,bounding_box:{y_start:g,height:h-g},is_copper_plane:y!==void 0});break}case"soldermask":{const g=h;let y=!1;const k=P(_.id,_.orientation);if(k)h+=t(k.height);else{const $=t(_.height);if(y=!0,H(_.id,_.orientation)){const j=t(_.trace_height);J[_.id]=j;const F=t(_.etch_factor)*j*2;G[_.id]=F,h+=j,h+=$}else h+=$}const z=h,W={y_start:g,height:z-g};let C;if(y){const $=t(_.height);_.orientation=="up"?C={y_start:g,height:$}:C={y_start:z-$,height:$}}K({type:"soldermask",parent:_,bounding_box:W,mask:C!==void 0?{surface:C,traces:[]}:void 0,is_copper_plane:k!==void 0});break}case"core":{const g=h,y=t(_.height);h+=y,K({type:"core",parent:_,bounding_box:{y_start:g,height:h-g}});break}case"prepreg":{const g=h;let y;const k=P(_.id,"up");if(k){const B=t(k.height);y={y_start:h,height:B},h+=B}else{const B=t(_.trace_height);if(J[_.id]=B,y={y_start:h,height:B},h+=B,H(_.id,"up")){const L=t(_.etch_factor)*B*2;G[_.id]=L}}const z=t(_.height),W={y_start:h,height:z};h+=z;let C;const $=P(_.id,"down");if($){const B=t($.height);C={y_start:h,height:B},h+=B}else{const B=t(_.trace_height);if(C={y_start:h,height:B},J[_.id]=B,h+=B,H(_.id,"down")){const L=t(_.etch_factor)*B*2;G[_.id]=L}}K({type:"prepreg",parent:_,bounding_box:{y_start:g,height:h-g},top:{shape:y,is_copper_plane:k!==void 0},middle_shape:W,bottom:{shape:C,is_copper_plane:$!==void 0}});break}}r.total_height=h,r.y_min=0,r.y_max=h}e==null||e.end(),e==null||e.begin("trace_layout_complete","Layout traces with vertical and horizontal dimensions");const Q={},tt={},vt=(h,_,g)=>{let y=Q[h];y===void 0&&(y={},Q[h]=y);let k=y[_];k===void 0&&(k=[],y[_]=k),k.push(g),tt[g.parent.id]=g};for(const h of o.conductors)switch(h.type){case"plane":{const _=h.position.layer_id,g=A[_];if(g===void 0)throw Error(`Plane references missing layer layout id ${_}`);const y=t(h.height),k=g.bounding_box.y_start,z=k+g.bounding_box.height,W=h.position.orientation=="up"?{y_start:k,y_end:k+y}:{y_start:z-y,y_end:z};r.conductors.push({type:"plane",parent:h,shape:{y_start:W.y_start,height:W.y_end-W.y_start}});break}case"trace":{const _=h.position.layer_id,g=A[_];if(g===void 0)throw Error(`Plane references invalid layer layout id ${_}`);const y=u[h.id];if(y===void 0)throw Error(`Trace does not have an x region ${h.id}`);const k=G[_];if(k===void 0)throw Error(`Plane references layer id without trace taper ${_}`);const z=J[_];if(z===void 0)throw Error(`Plane references layer id without trace height ${_}`);const W=g.bounding_box.y_start,C=W+g.bounding_box.height,$=h.position.orientation=="up"?{y_base:W,y_taper:W+z}:{y_base:C,y_taper:C-z},j={type:"trace",parent:h,shape:{x_left:y.x_left,x_right:y.x_right,x_left_taper:y.x_left+k/2,x_right_taper:y.x_right-k/2,...$}};r.conductors.push(j),vt(_,h.position.orientation,j);break}}e==null||e.end(),e==null||e.begin("spacing_layout_complete","Layout spacings with vertical and horizontal dimensions");function _t(h,..._){let g=0,y=1/0;for(const k of _){const z=Math.abs(h-k);z<y&&(g=k,y=z)}return g}for(let h=0;h<o.spacings.length;h++){const _=o.spacings[h],g=w[h];if(g===void 0)throw Error(`Spacing is missing x region ${h}`);const y=tt[_.left_trace.id];if(y===void 0)throw Error(`Spacing ${h} is missing left trace layout ${_.left_trace.id}`);const k=tt[_.right_trace.id];if(k===void 0)throw Error(`Spacing ${h} is missing right trace layout ${_.right_trace.id}`);const z=y.parent,W=k.parent,C=y.shape,$=k.shape,j=z.position.layer_id==W.position.layer_id?(C.y_base+$.y_base)/2:(C.y_base+C.y_taper+$.y_base+$.y_taper)/4,B=_.left_trace.attach=="center"?_t(j,C.y_base,C.y_taper):C.y_base,F=_.right_trace.attach=="center"?_t(j,$.y_base,$.y_taper):$.y_base;r.spacings.push({parent:_,left_anchor:{x:g.x_left,y:B},right_anchor:{x:g.x_right,y:F},y_mid:j})}e==null||e.end(),e==null||e.begin("soldermask_layout_complete","Layout soldermask with vertical and horizontal dimensions");for(const h of r.layers.filter(_=>_.type=="soldermask")){const _=h.parent,g=(lt=Q[_.id])==null?void 0:lt[_.orientation];if(g===void 0)continue;const y=t(_.height),k=_.orientation=="up"?y:-y;for(const z of g){const W=z.shape;(dt=h.mask)!=null&&dt.traces&&h.mask.traces.push({...W,y_base:W.y_base+k,y_taper:W.y_taper+k})}}return e==null||e.end(),r}class ct{constructor(){v(this,"occupied",new Set);v(this,"curr_head",0)}forward_head(){for(;this.occupied.has(this.curr_head);)this.curr_head+=1}borrow(){return this.curr_head}own(t){return t!==void 0?(this.occupied.add(t),this.forward_head(),t):(this.occupied.add(this.curr_head),t=this.curr_head,this.curr_head+=1,this.forward_head(),t)}free(t){return this.occupied.has(t)?(this.occupied.delete(t),this.curr_head=Math.min(this.curr_head,t),!0):!1}}class yt{constructor(){v(this,"curr_head",0)}own(t){return t!==void 0?(this.curr_head=Math.max(t,this.curr_head),t):(t=this.curr_head,this.curr_head+=1,t)}}const Y=9,Ht=12,D={soldermask_height:17,copper_layer_height:10,trace_height:20,etch_factor:.35,signal_trace_width:40,core_height:45,broadside_width_separation:35,signal_width_separation:30,ground_width_separation:30},q=(()=>{const t=Y*.6,e=5*2+Y*.6;return{min_arm_overhang:5,text_offset:t,center_overhang_margin:e}})();function N(o){return o==null?void 0:o.name}function Bt(o){return o==null?void 0:o.taper_suffix}function It(){return{stackup_minimum_width:150,stackup_minimum_x_padding:25}}class jt{constructor(t,e){v(this,"layout");v(this,"viewport");v(this,"stackup");v(this,"height_labels",[]);v(this,"width_labels",[]);v(this,"epsilon_labels",[]);v(this,"epsilon_label_x_offset");v(this,"voltage_labels",[]);v(this,"height_label_config");v(this,"conductors",[]);e===void 0&&(e=It());const r=Math.max(e.stackup_minimum_x_padding,e.stackup_minimum_width-t.total_width),i=t.x_min-r,d=t.x_max+r-i,c=t.total_height,n=t.y_min,u=23,l=i+Y/2,f=d+u,w=t.total_height,p=i-u,m=t.y_min;this.epsilon_label_x_offset=l,this.height_label_config={x_min:i-u,width:u},this.layout=t,this.viewport={width:f,height:w,x_min:p,y_min:m},this.stackup={x_min:i,y_min:n,width:d,height:c},this.create_height_labels(),this.create_copper_traces(),this.create_copper_planes(),this.conductors.sort((a,x)=>a.z_offset-x.z_offset),this.create_spacing_labels(),this.create_epsilon_labels(),this.fit_viewport_to_labels()}create_height_labels(){var s,d;const t={};for(const c of this.layout.conductors.filter(n=>n.type=="trace")){const n=c.parent;if(((s=n.viewer)==null?void 0:s.display)==="none")continue;const u=c.shape.x_left_taper;let l=t[n.position.layer_id];l===void 0&&(l={},t[n.position.layer_id]=l);const f=l[n.position.orientation];(f===void 0||f>u)&&(l[n.position.orientation]=u)}const e=(c,n)=>{var l;const u=(l=t[c])==null?void 0:l[n];return u===void 0?this.stackup.x_min:u-this.stackup.x_min};let r=1/0;for(const c of this.layout.layers)if(c.type!=="unmasked"){r=this.stackup.x_min;break}if(r==1/0)for(const c of this.layout.conductors.filter(n=>n.type=="trace"))((d=c.parent.viewer)==null?void 0:d.display)!=="none"&&(r=Math.min(r,c.shape.x_left));const i=r-this.stackup.x_min;for(const c of this.layout.layers)switch(c.type){case"unmasked":{const n=c.parent,u=N(n.trace_height),l=c.bounding_box.height,f=c.is_copper_plane;if(l>0&&!f&&u){const w=e(n.id,n.orientation);this.height_labels.push({y_offset:c.bounding_box.y_start,height:c.bounding_box.height,overhang_top:n.orientation=="up"?i:w,overhang_bottom:n.orientation=="up"?w:i,text:u})}break}case"soldermask":{const n=c.parent;if(c.mask){const u=c.mask.surface.height,l=N(n.height);if(c.mask.traces.length>0){const f=c.mask.traces[0],w=Math.abs(f.y_base-f.y_taper),p=N(n.trace_height),m=c.bounding_box.y_start,a=e(n.id,n.orientation);n.orientation=="down"?(l&&this.height_labels.push({y_offset:m,height:u,overhang_top:a,overhang_bottom:a,text:l}),p&&this.height_labels.push({y_offset:m+u,height:w,overhang_top:a,overhang_bottom:i,text:p})):(p&&this.height_labels.push({y_offset:m,height:w,overhang_top:i,overhang_bottom:a,text:p}),l&&this.height_labels.push({y_offset:m+w,height:u,overhang_top:a,overhang_bottom:a,text:l}))}else l&&this.height_labels.push({y_offset:c.mask.surface.y_start,height:u,overhang_top:i,overhang_bottom:i,text:l})}break}case"core":{const n=c.parent,u=N(n.height);c.bounding_box.height>0&&u&&this.height_labels.push({y_offset:c.bounding_box.y_start,height:c.bounding_box.height,overhang_top:i,overhang_bottom:i,text:u});break}case"prepreg":{const n=c.parent,u=N(n.trace_height),l=N(n.height);if(!c.top.is_copper_plane&&u){const f=e(n.id,"up");this.height_labels.push({y_offset:c.top.shape.y_start,height:c.top.shape.height,overhang_top:i,overhang_bottom:f,text:u})}if(l&&this.height_labels.push({y_offset:c.middle_shape.y_start,height:c.middle_shape.height,overhang_top:i,overhang_bottom:i,text:l}),!c.bottom.is_copper_plane&&u){const f=e(n.id,"down");this.height_labels.push({y_offset:c.bottom.shape.y_start,height:c.bottom.shape.height,overhang_top:f,overhang_bottom:i,text:u})}break}}}create_inline_width_label(t,e,r,i){const s={offset:{...t},width:e,y_offset_text:0,left_arm_overhang:{top:0,bottom:0},right_arm_overhang:{top:0,bottom:0},text:r};return i?(s.offset.y-=q.min_arm_overhang,s.left_arm_overhang.bottom=q.min_arm_overhang,s.right_arm_overhang.bottom=q.min_arm_overhang,s.left_arm_overhang.top=q.min_arm_overhang,s.right_arm_overhang.top=q.min_arm_overhang,s.y_offset_text=-5.3999999999999995):(s.offset.y+=q.min_arm_overhang,s.left_arm_overhang.top=q.min_arm_overhang,s.right_arm_overhang.top=q.min_arm_overhang,s.left_arm_overhang.bottom=q.min_arm_overhang,s.right_arm_overhang.bottom=q.min_arm_overhang,s.y_offset_text=q.text_offset),s}create_voltage_label(t,e){const r=(t.y_base+t.y_taper)/2,i=(t.x_left+t.x_right)/2;return{y_offset:r,x_offset:i,voltage:e}}create_copper_traces(){var e,r,i,s,d,c;const t={};for(const n of this.layout.layers)switch(n.type){case"core":break;case"soldermask":case"prepreg":case"unmasked":{const u=n.parent,l=Bt(u.etch_factor);t[u.id]=l;break}}for(const n of this.layout.conductors.filter(u=>u.type=="trace")){const u=n.shape,l=n.parent,f=((e=l.viewer)==null?void 0:e.display)||"solid",w=((r=l.viewer)==null?void 0:r.z_offset)!==void 0?(i=l.viewer)==null?void 0:i.z_offset:0;if(f=="none")continue;const p=N(l.width);let m=!1;if(p&&((s=l.viewer)==null?void 0:s.is_labeled)!==!1){m=!0;{const x={x:u.x_left,y:u.y_base},b=u.x_right-u.x_left,S=u.y_base<u.y_taper,H=this.create_inline_width_label(x,b,p,S);this.width_labels.push(H)}const a=t[l.position.layer_id];if(a){const x={x:u.x_left_taper,y:u.y_taper},b=u.x_right_taper-u.x_left_taper,S=u.y_base>u.y_taper,H=this.create_inline_width_label(x,b,`${p}${a}`,S);this.width_labels.push(H)}}if(f=="solid"){const a=this.create_voltage_label(u,l.voltage);this.voltage_labels.push(a)}this.conductors.push({type:"trace",id:l.id,shape:n.shape,is_selectable:f=="selectable",is_labeled:m,group_tag:(d=l.viewer)==null?void 0:d.group_tag,on_click:(c=l.viewer)==null?void 0:c.on_click,z_offset:w})}}create_copper_planes(){var t,e,r,i;for(const s of this.layout.conductors.filter(d=>d.type=="plane")){const d=s.parent,c=((t=d.viewer)==null?void 0:t.display)||"solid",n=((e=d.viewer)==null?void 0:e.z_offset)!==void 0?(r=d.viewer)==null?void 0:r.z_offset:0;c!=="none"&&this.conductors.push({type:"plane",shape:s.shape,on_click:(i=d.viewer)==null?void 0:i.on_click,is_selectable:c==="selectable",z_offset:n})}}create_spacing_labels(){var r;const t={};for(const i of this.layout.conductors.filter(s=>s.type=="trace")){const s=i.parent;t[s.id]=s.position.orientation}const e={};for(const i of this.conductors.filter(s=>s.type=="trace"))e[i.id]=i;for(const i of this.layout.spacings){const s=i.parent;if(((r=s.viewer)==null?void 0:r.is_display)===!1)continue;const d=s.left_trace.id,c=s.right_trace.id,n=e[d],u=e[c];if(!n||!u)continue;const l=N(s.width);if(!l)continue;const f=i.y_mid,w=i.left_anchor,p=i.right_anchor;if(Math.abs(w.y-p.y)<.001){const x=t[d]=="up",b={x:w.x,y:f},S=p.x-w.x,H=this.create_inline_width_label(b,S,l,x);this.width_labels.push(H)}else{const a=f-w.y,x=f-p.y,b=s.left_trace.attach=="center"&&n.is_labeled?q.center_overhang_margin:0,S=s.right_trace.attach=="center"&&u.is_labeled?q.center_overhang_margin:0;this.width_labels.push({offset:{x:w.x,y:f},width:p.x-w.x,mask_out_width:l.length*Y,y_offset_text:0,left_arm_overhang:{top:Math.max(a-b,q.min_arm_overhang),bottom:Math.max(-a-b,q.min_arm_overhang)},right_arm_overhang:{top:Math.max(x-S,q.min_arm_overhang),bottom:Math.max(-x-S,q.min_arm_overhang)},text:l})}}}create_epsilon_labels(){var t;for(const e of this.layout.layers)switch(e.type){case"unmasked":break;case"soldermask":{const r=(t=e.mask)==null?void 0:t.surface,i=N(e.parent.epsilon);if(r&&i){const s=r.y_start,d=s+r.height,c=(s+d)/2;this.epsilon_labels.push({y_offset:c,text:i})}break}case"core":case"prepreg":{const r=e.bounding_box,i=N(e.parent.epsilon);if(i){const s=r.y_start,d=s+r.height,c=(s+d)/2;this.epsilon_labels.push({y_offset:c,text:i})}break}}}fit_viewport_to_labels(){let t=1/0,e=-1/0,r=1/0,i=-1/0;for(const s of this.width_labels){const d=s.offset.x,c=d+s.width,n=s.offset.y+Math.max(s.left_arm_overhang.top,s.right_arm_overhang.top),u=s.offset.y+Math.max(s.left_arm_overhang.bottom,s.right_arm_overhang.bottom),l=s.offset.y+s.y_offset_text,f=l-Y*.5,w=l+Y*.5;t=Math.min(t,d,c),e=Math.max(e,d,c),r=Math.min(r,n,u,f),i=Math.max(i,n,u,w)}this.fit_viewport_to_bounds(t,e,r,i)}fit_viewport_to_bounds(t,e,r,i){const s=Math.max(0,this.viewport.x_min-t),d=Math.max(0,e-this.viewport.width+this.viewport.x_min),c=Math.max(0,this.viewport.y_min-r),n=Math.max(0,i-this.viewport.height+this.viewport.y_min);this.viewport.x_min-=s,this.viewport.y_min-=c,this.viewport.width+=s+d,this.viewport.height+=c+n}}class rt{constructor(t){v(this,"cache",new Map);v(this,"ctor");this.ctor=t}get(t){let e=this.cache.get(t);return e!==void 0||(e=this.ctor(t),this.cache.set(t,e)),e}for_each(t){for(const e of this.cache.values())t(e)}}class ne{constructor(t){v(this,"id_to_index",{});v(this,"required_trace_widths",new Set);v(this,"required_etch_factors",new Set);v(this,"minimum_feature_size",1e-4);v(this,"user_data");v(this,"etch_factor");v(this,"T");v(this,"SH");v(this,"H");v(this,"ER");v(this,"PH");v(this,"W");v(this,"CW");v(this,"S");v(this,"B");v(this,"CS");v(this,"size_unit_options",["cm","mm","um","inch","mil","thou"]);v(this,"copper_thickness_unit_options",["cm","mm","um","inch","mil","thou","oz"]);this.user_data=t;const e=(i,s,d)=>({value:U(i,s,d),unit:d}),r=(i,s)=>({type:"size",parent:this,name:i,description:s,get min(){let d=0;for(const n of this.parent.required_etch_factors){const u=this.parent.etch_factor.get(n),l=this.parent.T.get(n);if(l.value===void 0||u.value===void 0)continue;const f=U(l.value,l.unit,this.unit),p=2*u.value*f;d=Math.max(d,p)}const c=this.parent.minimum_feature_size;return Math.max(c,d)},...e(.25,"mm",this.size_unit),placeholder_value:D.signal_trace_width,impedance_correlation:"negative"});this.etch_factor=new rt(i=>({type:"etch_factor",parent:this,get name(){return`EF${this.parent.get_index(i)}`},description:"Trace taper",get taper_suffix(){return`${this.parent.get_index(i)}`},min:0,get max(){const s=this.parent.T.get(i);if(s.value===void 0)return;const d=U(s.value,s.unit,this.parent.size_unit);let c=1/0;for(const u of this.parent.required_trace_widths)if(u.value!==void 0){const l=U(u.value,u.unit,this.parent.size_unit);c=Math.min(c,l)}return c===1/0?void 0:.5*c/d},...e(0,"mm",this.size_unit),placeholder_value:D.etch_factor,impedance_correlation:"positive"})),this.T=new rt(i=>({type:"size",parent:this,get name(){return`T${this.parent.get_index(i)}`},description:"Trace thickness",get min(){return this.parent.minimum_feature_size},...e(1,"oz",this.copper_thickness_unit),placeholder_value:D.trace_height,impedance_correlation:"negative"})),this.SH=new rt(i=>({type:"size",parent:this,get name(){return`H${this.parent.get_index(i)}`},description:"Soldermask thickness",get min(){return this.parent.minimum_feature_size},...e(.015,"mm",this.size_unit),placeholder_value:D.soldermask_height,impedance_correlation:"negative"})),this.H=new rt(i=>({type:"size",parent:this,get name(){return`H${this.parent.get_index(i)}`},description:"Dielectric height",get min(){return this.parent.minimum_feature_size},...e(.15,"mm",this.size_unit),placeholder_value:D.core_height,impedance_correlation:"positive"})),this.ER=new rt(i=>({type:"epsilon",parent:this,get name(){return`ER${this.parent.get_index(i)}`},description:"Dielectric constant",min:1,value:4.1,impedance_correlation:"negative"})),this.PH={type:"size",...e(.1,"mm",this.copper_thickness_unit),placeholder_value:D.copper_layer_height},this.W=r("W","Trace width"),this.CW=r("CW","Coplanar ground width"),this.S={parent:this,type:"size",name:"S",description:"Signal separation",get min(){return this.parent.minimum_feature_size},...e(.25,"mm",this.size_unit),placeholder_value:D.signal_width_separation,impedance_correlation:"positive"},this.B={parent:this,type:"size",name:"BS",description:"Broadside separation",min:0,...e(0,"mm",this.size_unit),placeholder_value:D.broadside_width_separation,impedance_correlation:"positive"},this.CS={parent:this,type:"size",name:"CS",description:"Coplanar ground separation",get min(){return this.parent.minimum_feature_size},...e(.25,"mm",this.size_unit),placeholder_value:D.ground_width_separation,impedance_correlation:"positive"}}get_index(t){const e=this.id_to_index[t];if(e===void 0)throw Error(`Failed to get layer index of layer id ${t}`);return e}for_each(t){this.etch_factor.for_each(t),this.T.for_each(t),this.SH.for_each(t),this.H.for_each(t),this.ER.for_each(t),t(this.PH),t(this.W),t(this.CW),t(this.S),t(this.B),t(this.CS)}validate_parameter(t){if(t.value===void 0)throw t.error="Field is required",Error(`Missing field value for ${t.name}`);if(typeof t.value!="number")throw t.error="Field is required",Error(`Non number field value for ${t.name}`);if(Number.isNaN(t.value))throw t.error="Field is required",Error(`NaN field value for ${t.name}`);if(t.min!==void 0&&t.value<t.min)throw t.error=`Value must be greater than ${t.min}`,Error(`Violated minimum value for ${t.name}`);if(t.max!==void 0&&t.value>t.max)throw t.error=`Value must be less than ${t.max}`,Error(`Violated maximum value for ${t.name}`);return t.error=void 0,t}get_simulation_parameter(t){const e=this.validate_parameter(t);switch(e.type){case"size":return U(e.value,e.unit,this.size_unit);case"etch_factor":return e.value;case"epsilon":return e.value}}get size_unit(){return this.user_data.size_unit}set size_unit(t){this.user_data.size_unit=t;const e=r=>{const i=r.unit;if(r.unit=t,r.value!==void 0){const s=U(r.value,i,t);r.value=s}};this.SH.for_each(e),this.H.for_each(e),e(this.W),e(this.CW),e(this.S),e(this.B),e(this.CS)}get copper_thickness_unit(){return this.user_data.copper_thickness_unit}set copper_thickness_unit(t){this.user_data.copper_thickness_unit=t;const e=r=>{const i=r.unit;if(r.unit=t,r.value!==void 0){const s=U(r.value,i,t);r.value=s}};this.T.for_each(e),e(this.PH)}mark_parameter_unchanged(t){t.old_value=t.value,t.error=void 0,t.type==="size"&&(t.old_unit=t.unit)}mark_parameter_changed(t){t.old_value=void 0,t.error=void 0,t.type==="size"&&(t.old_unit=void 0)}}const T={can_layer_contain_conductor_orientation(o,t){switch(o.type){case"core":return!1;case"prepreg":return!0;case"unmasked":return o.orientation==t;case"soldermask":return o.orientation==t}},will_layer_leave_conductors_floating(o,t){for(const e of t)if(this.is_conductor_in_layer(o,e)&&!this.can_layer_contain_conductor_orientation(o,e.position.orientation))return!0;return!1},is_conductor_in_layer(o,t,e){return o.id!=t.position.layer_id?!1:e===void 0?!0:t.position.orientation==e},are_some_conductors_in_layer(o,t){for(const e of t)if(T.is_conductor_in_layer(o,e))return!0;return!1},is_shorting(o,t,e){if(!(t&&e))return!1;let r=!1,i=!1;if(t){for(const s of o)if(this.is_conductor_in_layer(t,s,"down")){r=!0;break}}if(e){for(const s of o)if(this.is_conductor_in_layer(e,s,"up")){i=!0;break}}return r&&i},can_layer_support_adjacent_layer(o,t){switch(o.type){case"core":return!0;case"prepreg":return!0;case"unmasked":return o.orientation==t;case"soldermask":return o.orientation==t}}},R={core(o,t){return{type:"core",id:t,height:o.H.get(t),epsilon:o.ER.get(t)}},prepreg(o,t){return{type:"prepreg",id:t,height:o.H.get(t),epsilon:o.ER.get(t),trace_height:o.T.get(t),etch_factor:o.etch_factor.get(t)}},soldermask(o,t,e){return{type:"soldermask",id:t,height:o.SH.get(t),epsilon:o.ER.get(t),trace_height:o.T.get(t),etch_factor:o.etch_factor.get(t),orientation:e}},unmasked(o,t,e){return{type:"unmasked",id:t,trace_height:o.T.get(t),etch_factor:o.etch_factor.get(t),orientation:e}},with_type(o,t,e,r){switch(t){case"core":return this.core(o,e);case"prepreg":return this.prepreg(o,e);case"soldermask":return this.soldermask(o,e,r);case"unmasked":return this.unmasked(o,e,r)}}};function O(o,t){return{type:"plane",position:t,height:o.PH,voltage:"ground"}}class mt{constructor(t){v(this,"layers",[]);v(this,"layer_id",new ct);v(this,"parameters");v(this,"plane_conductors",[]);this.parameters=t}get_adjacent_layers(t){const e=this.layers.length,r=t>0?this.layers[t-1]:void 0,i=t<e-1?this.layers[t+1]:void 0;return[r,i]}regenerate_layer_id_to_index(){for(let t=0;t<this.layers.length;t++){const e=this.layers[t];this.parameters.id_to_index[e.id]=t}}regenerate_trace_parameter_constraints(){this.parameters.required_trace_widths.clear(),this.parameters.required_etch_factors.clear();for(const t of this.get_sim_conductors())t.type=="trace"&&(this.parameters.required_trace_widths.add(t.width),this.parameters.required_etch_factors.add(t.position.layer_id))}try_add_prepreg_layer(t){const e=t>0?this.layers[t-1]:void 0,r=t<this.layers.length?this.layers[t]:void 0;if(e&&!T.can_layer_support_adjacent_layer(e,"down")||r&&!T.can_layer_support_adjacent_layer(r,"up"))return;const i=R.prepreg(this.parameters,this.layer_id.borrow());return()=>{this.layers.splice(t,0,i),this.layer_id.own(i.id),this.regenerate_layer_id_to_index()}}try_change_layer_type(t,e){const r=this.layers[t],[i,s]=this.get_adjacent_layers(t),d=t==0?"down":"up",c=R.with_type(this.parameters,e,r.id,d);if(i&&!T.can_layer_support_adjacent_layer(c,"up")||s&&!T.can_layer_support_adjacent_layer(c,"down"))return;const n=this.get_sim_conductors();if(!T.is_shorting(n,i,c)&&!T.is_shorting(n,c,s)&&!T.will_layer_leave_conductors_floating(c,n))return()=>{this.layers.splice(t,1,c),this.regenerate_layer_id_to_index()}}try_delete_layer(t){const[e,r]=this.get_adjacent_layers(t),i=this.layers[t];if(this.layers.length<=1)return;const s=this.get_sim_conductors();if(!T.are_some_conductors_in_layer(i,s)&&!(e&&r&&(T.is_shorting(s,e,r)||!T.can_layer_support_adjacent_layer(e,"down")||!T.can_layer_support_adjacent_layer(r,"up"))))return()=>{this.layers.splice(t,1),this.layer_id.free(i.id),this.regenerate_layer_id_to_index()}}remove_plane(t){const e=this.plane_conductors.findIndex(r=>r.position.layer_id==t.layer_id&&r.position.orientation==t.orientation);e>=0&&this.plane_conductors.splice(e,1)}hide_spacing(t){return t.viewer===void 0&&(t.viewer={}),t.viewer.is_display=!1,t}make_plane_removable(t){return t.grid={override_total_divisions:1},t.viewer={on_click:()=>this.remove_plane(t.position)},t}make_plane_selectable(t){return t.viewer={is_labeled:!1,display:"selectable",on_click:()=>{const e=O(this.parameters,t.position);this.plane_conductors.push(e)}},t.layout={shrink_trace_layer:!1},t}make_trace_selectable(t,e,r){return t.viewer={...t.viewer,is_labeled:!1,display:"selectable",on_click:r,group_tag:e},t}}class ce extends mt{constructor(e,r,i){super(e);v(this,"trace_ids",new ct);v(this,"trace");v(this,"trace_template");this.trace_template=r;const{layers:s,plane_conductors:d,trace_position:c}=i.create(this.parameters,this.layer_id);this.layers=s,this.plane_conductors=d,this.regenerate_layer_id_to_index(),this.trace=this.trace_template.create(this.parameters,c,this.trace_ids),this.regenerate_trace_parameter_constraints()}set_trace_template(e){this.trace_template=e;for(const r of this.trace.conductors)this.trace_ids.free(r.id);this.trace=this.trace_template.create(this.parameters,this.trace.position,this.trace_ids),this.regenerate_trace_parameter_constraints()}get_sim_conductors(){return[...this.trace.conductors,...this.plane_conductors]}get_sim_spacings(){return this.trace.spacings}get_simulation_stackup(){const e=this.get_sim_conductors(),r=this.get_sim_spacings();return{layers:this.layers,spacings:r,conductors:e}}make_colinear_trace_conductors_selectable(e){const r=`${e.position.layer_id}_${e.position.orientation}`;for(const i of e.conductors)this.make_trace_selectable(i,r,()=>{for(const d of this.trace.conductors)this.trace_ids.free(d.id);const s=this.trace_template.create(this.parameters,i.position,this.trace_ids);this.trace=s,this.regenerate_trace_parameter_constraints()});for(const i of e.spacings)this.hide_spacing(i)}create_parallel_spacing(e,r){return{left_trace:{id:e,attach:"left"},right_trace:{id:r,attach:"left"},width:{type:"size",unit:"mm",placeholder_value:0}}}get_viewer_stackup(){const e=this.get_sim_conductors(),r=this.get_sim_spacings(),i=[],s=[];for(let l of e)l.type=="plane"&&(l=this.make_plane_removable({...l})),i.push(l);for(const l of r)s.push(l);const d={};for(const l of e){const{layer_id:f,orientation:w}=l.position;let p=d[f];p===void 0&&(p=new Set,d[f]=p),p.add(w)}const c=(l,f)=>{const w=d[l];return w===void 0?!1:w.has(f)},n=new yt;n.curr_head=this.trace_ids.borrow();const u=["up","down"];for(let l=0;l<this.layers.length;l++){const f=this.layers[l],[w,p]=this.get_adjacent_layers(l),m=a=>T.is_shorting(a,w,f)||T.is_shorting(a,f,p);for(const a of u){if(c(f.id,a)||!T.can_layer_contain_conductor_orientation(f,a))continue;const x={layer_id:f.id,orientation:a},b=this.trace_template.create(this.parameters,x,n);if(!m([...b.conductors,...this.plane_conductors])){this.make_colinear_trace_conductors_selectable(b);for(const P of b.conductors)i.push(P);for(const P of b.spacings)s.push(P);const H=this.create_parallel_spacing(this.trace.conductors[0].id,b.conductors[0].id);this.hide_spacing(H),s.push(H)}const S=O(this.parameters,x);m([...e,S])||(this.make_plane_selectable(S),i.push(S))}}return{layers:this.layers,conductors:i,spacings:s}}}class _e extends mt{constructor(e,r,i){super(e);v(this,"trace_ids",new ct);v(this,"left");v(this,"right");v(this,"broadside_spacing");v(this,"trace_template");this.trace_template=r;const{layers:s,plane_conductors:d,left_trace_position:c,right_trace_position:n}=i.create(this.parameters,this.layer_id);this.layers=s,this.plane_conductors=d,this.regenerate_layer_id_to_index(),this.left=this.trace_template.create_left(this.parameters,c,this.trace_ids),this.right=this.trace_template.create_right(this.parameters,n,this.trace_ids),this.broadside_spacing=this.create_broadside_spacing(this.left.root.id,this.right.root.id),this.regenerate_trace_parameter_constraints()}set_trace_template(e){this.trace_template=e;const r=this.left.position,i=this.right.position;this.left=this.trace_template.create_left(this.parameters,r,this.trace_ids),this.right=this.trace_template.create_right(this.parameters,i,this.trace_ids),this.broadside_spacing=this.create_broadside_spacing(this.left.root.id,this.right.root.id),this.regenerate_trace_parameter_constraints()}create_broadside_spacing(e,r){return{left_trace:{id:e,attach:"center"},right_trace:{id:r,attach:"center"},width:this.parameters.B}}get_sim_conductors(){return[...this.left.conductors,...this.right.conductors,...this.plane_conductors]}get_sim_spacings(){return[...this.left.spacings,this.broadside_spacing,...this.right.spacings]}get_simulation_stackup(){const e=this.get_sim_conductors(),r=this.get_sim_spacings();return{layers:this.layers,spacings:r,conductors:e}}make_left_trace_selectable(e){const r=`${e.position.layer_id}_${e.position.orientation}_left`;for(const i of e.conductors)this.make_trace_selectable(i,r,()=>{for(const c of this.left.conductors)this.trace_ids.free(c.id);const s=this.trace_template.create_left(this.parameters,e.position,this.trace_ids),d=this.create_broadside_spacing(s.root.id,this.right.root.id);this.left=s,this.broadside_spacing=d,this.regenerate_trace_parameter_constraints()});for(const i of e.spacings)this.hide_spacing(i)}make_right_trace_selectable(e){const r=`${e.position.layer_id}_${e.position.orientation}_right`;for(const i of e.conductors)this.make_trace_selectable(i,r,()=>{for(const c of this.right.conductors)this.trace_ids.free(c.id);const s=this.trace_template.create_right(this.parameters,e.position,this.trace_ids),d=this.create_broadside_spacing(this.left.root.id,s.root.id);this.right=s,this.broadside_spacing=d,this.regenerate_trace_parameter_constraints()});for(const i of e.spacings)this.hide_spacing(i)}get_viewer_stackup(){const e=this.get_sim_conductors(),r=this.get_sim_spacings(),i=[],s=[];for(let l of e)l.type=="plane"&&(l=this.make_plane_removable({...l})),i.push(l);for(const l of r)s.push(l);const d={};for(const l of e){const{layer_id:f,orientation:w}=l.position;let p=d[f];p===void 0&&(p=new Set,d[f]=p),p.add(w)}const c=(l,f)=>{const w=d[l];return w===void 0?!1:w.has(f)},n=new yt;n.curr_head=this.trace_ids.borrow();const u=["up","down"];for(let l=0;l<this.layers.length;l++){const f=this.layers[l],[w,p]=this.get_adjacent_layers(l),m=a=>T.is_shorting(a,w,f)||T.is_shorting(a,f,p);for(const a of u){if(c(f.id,a)||!T.can_layer_contain_conductor_orientation(f,a))continue;const x={layer_id:f.id,orientation:a},b=this.trace_template.create_left(this.parameters,x,n);if(!m([...b.conductors,...this.right.conductors,...this.plane_conductors])){this.make_left_trace_selectable(b);for(const A of b.conductors)i.push(A);for(const A of b.spacings)s.push(A);const P=this.create_broadside_spacing(b.root.id,this.right.root.id);this.hide_spacing(P),s.push(P)}const S=this.trace_template.create_right(this.parameters,x,n);if(!m([...S.conductors,...this.left.conductors,...this.plane_conductors])){this.make_right_trace_selectable(S);for(const A of S.conductors)i.push(A);for(const A of S.spacings)s.push(A);const P=this.create_broadside_spacing(this.left.root.id,S.root.id);this.hide_spacing(P),s.push(P)}const H=O(this.parameters,x);m([...e,H])||(this.make_plane_selectable(H),i.push(H))}}return{layers:this.layers,conductors:i,spacings:s}}}const Tt=["viewBox"],Pt=["points","fill","stroke","stroke-width"],qt=["x","y","width","height","fill","stroke","stroke-width"],At=["x","y","width","height","fill","stroke","stroke-width"],Rt=["points","fill","stroke","stroke-width","onClick","onMouseenter","onMouseleave","group_tag"],Ft=["x","y","width","height","fill","stroke","stroke-width","onClick"],Vt=["transform"],Nt=["transform"],Lt=["x2","stroke","stroke-width","stroke-dasharray"],Dt=["x2","y1","y2","stroke","stroke-width","stroke-dasharray"],Yt=["y","font-size"],Gt=["transform"],Jt=["y2"],Kt=["transform"],Ot=["transform"],Qt=["y1","y2","stroke","stroke-width","stroke-dasharray"],Ut=["x1","x2","y1","y2","stroke","stroke-width","stroke-dasharray"],Xt=["x","y","font-size"],Zt=["x2","stroke","stroke-width"],te=["x1","x2","stroke","stroke-width"],ee=["x2","stroke","stroke-width"],ie=["transform"],re=["x","y","font-size"],st=.5,oe=kt({__name:"StackupViewer",props:{stackup:{},config:{}},setup(o){const t=o,e=ut(()=>{const p=x=>{switch(x.type){case"epsilon":return 1;case"etch_factor":return x.placeholder_value;case"size":return x.placeholder_value}},m=Wt(t.stackup,p);return new jt(m,t.config)}),r=bt(new Set);function i(p){p!==void 0&&r.value.add(p)}function s(p){p!==void 0&&r.value.delete(p)}function d(p){return p===void 0?!1:r.value.has(p)}zt(e,()=>{r.value.clear()});const c={copper:"#eacc2d",dielectric_soldermask:"#00aa00",dielectric_prepreg:"#55cc33",dielectric_core:"#88ed44"},n={outline_colour:"#00000040",outline_width:.5,arm_colour:"#000000",arm_width:.5,arm_dash_array:"2,2",line_colour:"#000000",line_width:.5};function u(p){return p.map(({x:m,y:a})=>`${m},${a}`).join(" ")}function l(p){return[{x:p.x_left,y:p.y_base},{x:p.x_left_taper,y:p.y_taper},{x:p.x_right_taper,y:p.y_taper},{x:p.x_right,y:p.y_base}]}const f=p=>{const m=p.mask,a=[];if(m===void 0)return a;const x=p.parent.orientation,b=m.surface.y_start,S=b+m.surface.height,H=x=="up"?S:b,P=x=="up"?b:S,A=e.value.stackup.x_min,G=A+e.value.stackup.width;a.push({x:A,y:P}),a.push({x:A,y:H});const J=[...m.traces];J.sort((K,Q)=>K.x_left-Q.x_left);for(const K of J){const Q=l(K);for(const tt of Q)a.push(tt)}return a.push({x:G,y:H}),a.push({x:G,y:P}),a},w=ut(()=>e.value.voltage_labels.filter(p=>p.voltage!=="ground").map(p=>{let m;switch(p.voltage){case"ground":break;case"negative":m=Mt;break;case"positive":m=Et;break}return{x:p.x_offset,y:p.y_offset,icon:m}}));return(p,m)=>(M(),E("svg",{version:"1.1",xmlns:"http://www.w3.org/2000/svg",viewBox:`
    ${e.value.viewport.x_min-st} ${e.value.viewport.y_min-st}
    ${e.value.viewport.width+st*2} ${e.value.viewport.height+st*2}
  `,preserveAspectRatio:"xMidYMid meet",class:"w-full"},[(M(!0),E(V,null,X(e.value.layout.layers,(a,x)=>(M(),E(V,{key:x},[a.type=="soldermask"?(M(),E(V,{key:0},[a.mask?(M(),E("polygon",{key:0,points:u(f(a)),fill:c.dielectric_soldermask,stroke:n.outline_colour,"stroke-width":n.outline_width},null,8,Pt)):Z("",!0)],64)):Z("",!0),a.type=="core"?(M(),E("rect",{key:1,x:e.value.stackup.x_min,y:a.bounding_box.y_start,width:e.value.stackup.width,height:a.bounding_box.height,fill:c.dielectric_core,stroke:n.outline_colour,"stroke-width":n.outline_width},null,8,qt)):Z("",!0),a.type=="prepreg"?(M(),E("rect",{key:2,x:e.value.stackup.x_min,y:a.bounding_box.y_start,width:e.value.stackup.width,height:a.bounding_box.height,fill:c.dielectric_prepreg,stroke:n.outline_colour,"stroke-width":n.outline_width},null,8,At)):Z("",!0)],64))),128)),(M(!0),E(V,null,X(e.value.conductors,(a,x)=>(M(),E(V,{key:x},[a.type==="trace"?(M(),E("polygon",{key:0,class:pt(`
          ${a.is_selectable?"trace-selectable":""}
          ${a.on_click?"trace-clickable":""}
          ${d(a.group_tag)?"trace-selectable-group-hover":""}
        `),points:u(l(a.shape)),fill:c.copper,stroke:n.outline_colour,"stroke-width":n.outline_width,onClick:()=>{var b;return(b=a.on_click)==null?void 0:b.call(a)},onMouseenter:()=>i(a.group_tag),onMouseleave:()=>s(a.group_tag),group_tag:a.group_tag},null,42,Rt)):a.type==="plane"?(M(),E("rect",{key:1,class:pt(`
          ${a.is_selectable?"trace-selectable":""}
          ${a.on_click?"trace-clickable":""}
        `),x:e.value.stackup.x_min,y:a.shape.y_start,width:e.value.stackup.width,height:a.shape.height,fill:c.copper,stroke:n.outline_colour,"stroke-width":n.outline_width,onClick:()=>{var b;return(b=a.on_click)==null?void 0:b.call(a)}},null,10,Ft)):Z("",!0)],64))),128)),(M(!0),E(V,null,X(w.value,(a,x)=>(M(),E(V,{key:x},[a.icon!==void 0?(M(),E("g",{key:0,transform:`translate(${a.x},${a.y}) scale(${ot(Ht)})`},[(M(),$t(St(a.icon),{x:"-0.5",y:"-0.5",width:"1",height:"1",stroke:"black"}))],8,Vt)):Z("",!0)],64))),128)),(M(!0),E(V,null,X(e.value.height_labels,(a,x)=>(M(),E("g",{key:x,transform:`translate(${e.value.height_label_config.x_min},${a.y_offset})`},[I("line",{x1:"0",x2:e.value.height_label_config.width+a.overhang_top,y1:"0",y2:"0",stroke:n.arm_colour,"stroke-width":n.arm_width,"stroke-dasharray":n.arm_dash_array},null,8,Lt),I("line",{x1:"0",x2:e.value.height_label_config.width+a.overhang_bottom,y1:a.height,y2:a.height,stroke:n.arm_colour,"stroke-width":n.arm_width,"stroke-dasharray":n.arm_dash_array},null,8,Dt),I("text",{x:"1",y:a.height/2,"font-size":ot(Y),"font-weight":"500","alignment-baseline":"central"},nt(a.text),9,Yt),I("g",{transform:`translate(${e.value.height_label_config.width-5},0)`},[I("line",{x1:"0",x2:"0",y1:2,y2:a.height-2,stroke:"#000000","stroke-width":"0.5"},null,8,Jt),m[1]||(m[1]=I("g",{transform:"translate(0,2)"},[I("polygon",{points:"-2,2 0,-2 2,2",fill:"#000000"})],-1)),I("g",{transform:`translate(0,${a.height-2}) scale(1,-1)`},m[0]||(m[0]=[I("polygon",{points:"-2,2 0,-2 2,2",fill:"#000000"},null,-1)]),8,Kt)],8,Gt)],8,Nt))),128)),(M(!0),E(V,null,X(e.value.width_labels,(a,x)=>(M(),E("g",{key:x,transform:`translate(${a.offset.x}, ${a.offset.y})`},[I("line",{x1:"0",x2:"0",y1:a.left_arm_overhang.bottom,y2:-a.left_arm_overhang.top,stroke:n.arm_colour,"stroke-width":n.arm_width,"stroke-dasharray":n.arm_dash_array},null,8,Qt),I("line",{x1:a.width,x2:a.width,y1:a.right_arm_overhang.bottom,y2:-a.right_arm_overhang.top,stroke:n.arm_colour,"stroke-width":n.arm_width,"stroke-dasharray":n.arm_dash_array},null,8,Ut),I("text",{x:a.width/2,y:a.y_offset_text,"font-size":ot(Y),"text-anchor":"middle","font-weight":"500","alignment-baseline":"central"},nt(a.text),9,Xt),I("g",null,[a.mask_out_width?(M(),E(V,{key:0},[I("line",{x1:"0",x2:a.width/2-a.mask_out_width/2,y1:"0",y2:"0",stroke:n.line_colour,"stroke-width":n.line_width},null,8,Zt),I("line",{x1:a.width/2+a.mask_out_width/2,x2:a.width,y1:"0",y2:"0",stroke:n.line_colour,"stroke-width":n.line_width},null,8,te)],64)):(M(),E("line",{key:1,x1:"0",x2:a.width,y1:"0",y2:"0",stroke:n.line_colour,"stroke-width":n.line_width},null,8,ee)),m[3]||(m[3]=I("g",{transform:"translate(2,0)"},[I("polygon",{points:"-2,0 2,2 2,-2",fill:"#000000"})],-1)),I("g",{transform:`translate(${a.width-2},0) scale(1,-1)`},m[2]||(m[2]=[I("polygon",{points:"2,0 -2,2 -2,-2",fill:"#000000"},null,-1)]),8,ie)])],8,Ot))),128)),(M(!0),E(V,null,X(e.value.epsilon_labels,(a,x)=>(M(),E("text",{key:x,x:e.value.epsilon_label_x_offset,y:a.y_offset,"font-size":ot(Y),"font-weight":"500","alignment-baseline":"central"},nt(a.text),9,re))),128))],8,Tt))}}),he=Ct(oe,[["__scopeId","data-v-a159e897"]]),le={"single ended":{create(o,t,e){const i=[{type:"trace",id:Array.from({length:1},d=>e.own())[0],position:t,width:o.W,voltage:"positive"}];return{position:t,conductors:i,spacings:[]}}},pair:{create(o,t,e){const r=Array.from({length:2},d=>e.own()),i=[{type:"trace",id:r[0],position:t,width:o.W,voltage:"positive"},{type:"trace",id:r[1],position:t,width:o.W,voltage:"negative"}],s=[{left_trace:{id:r[0],attach:"right"},right_trace:{id:r[1],attach:"left"},width:o.S}];return{position:t,conductors:i,spacings:s}}},"coplanar pair":{create(o,t,e){const r=Array.from({length:4},d=>e.own()),i=[{type:"trace",id:r[0],position:t,width:o.CW,voltage:"ground"},{type:"trace",id:r[1],position:t,width:o.W,voltage:"positive"},{type:"trace",id:r[2],position:t,width:o.W,voltage:"negative"},{type:"trace",id:r[3],position:t,width:o.CW,voltage:"ground"}],s=[{left_trace:{id:r[0],attach:"right"},right_trace:{id:r[1],attach:"left"},width:o.CS},{left_trace:{id:r[1],attach:"right"},right_trace:{id:r[2],attach:"left"},width:o.S},{left_trace:{id:r[2],attach:"right"},right_trace:{id:r[3],attach:"left"},width:o.CS}];return{position:t,conductors:i,spacings:s}}},"coplanar single ended":{create(o,t,e){const r=Array.from({length:3},d=>e.own()),i=[{type:"trace",id:r[0],position:t,width:o.CW,voltage:"ground"},{type:"trace",id:r[1],position:t,width:o.W,voltage:"positive"},{type:"trace",id:r[2],position:t,width:o.CW,voltage:"ground"}],s=[{left_trace:{id:r[0],attach:"right"},right_trace:{id:r[1],attach:"left"},width:o.CS},{left_trace:{id:r[1],attach:"right"},right_trace:{id:r[2],attach:"left"},width:o.CS}];return{position:t,conductors:i,spacings:s}}}},de={microstrip:{create(o,t){const e=R.soldermask(o,t.own(),"down"),r=R.core(o,t.own()),i=R.unmasked(o,t.own(),"up"),s=O(o,{layer_id:i.id,orientation:i.orientation});return{layers:[e,r,i],plane_conductors:[s],trace_position:{layer_id:e.id,orientation:e.orientation}}}},stripline:{create(o,t){const e=R.prepreg(o,t.own()),r=R.core(o,t.own()),i=R.unmasked(o,t.own(),"up"),s=O(o,{layer_id:e.id,orientation:"up"}),d=O(o,{layer_id:i.id,orientation:i.orientation});return{layers:[e,r,i],plane_conductors:[s,d],trace_position:{layer_id:e.id,orientation:"down"}}}}},ue={microstrip:{create(o,t){const e=R.soldermask(o,t.own(),"down"),r=R.core(o,t.own()),i=R.soldermask(o,t.own(),"up");return{layers:[e,r,i],plane_conductors:[],left_trace_position:{layer_id:e.id,orientation:e.orientation},right_trace_position:{layer_id:i.id,orientation:i.orientation}}}},stripline:{create(o,t){const e=R.prepreg(o,t.own()),r=R.core(o,t.own()),i=R.prepreg(o,t.own()),s=O(o,{layer_id:e.id,orientation:"up"}),d=O(o,{layer_id:i.id,orientation:"down"});return{layers:[e,r,i],plane_conductors:[s,d],left_trace_position:{layer_id:e.id,orientation:"down"},right_trace_position:{layer_id:i.id,orientation:"up"}}}}};function gt(o){if(o!=="positive"&&o!=="negative")throw Error(`Cannot get the opposite voltage for ${o}`);return o=="positive"?"negative":"positive"}const pe={pair:{create_traces(o,t,e,r){const s=[{type:"trace",id:Array.from({length:1},n=>r.own())[0],position:t,width:o.W,voltage:e}],d=s[0];return{position:t,root:d,conductors:s,spacings:[]}},create_left(o,t,e){return this.create_traces(o,t,"positive",e)},create_right(o,t,e){return this.create_traces(o,t,"negative",e)}},"coplanar pair":{create_traces(o,t,e,r){const i=Array.from({length:3},n=>r.own()),s=[{type:"trace",id:i[0],position:t,width:o.CW,voltage:"ground"},{type:"trace",id:i[1],position:t,width:o.W,voltage:e},{type:"trace",id:i[2],position:t,width:o.CW,voltage:"ground"}],d=s[1],c=[{left_trace:{id:i[0],attach:"right"},right_trace:{id:i[1],attach:"left"},width:o.CS},{left_trace:{id:i[1],attach:"right"},right_trace:{id:i[2],attach:"left"},width:o.CS}];return{position:t,root:d,conductors:s,spacings:c}},create_left(o,t,e){return this.create_traces(o,t,"positive",e)},create_right(o,t,e){return this.create_traces(o,t,"negative",e)}},"mirrored pair":{create_traces(o,t,e,r){const i=Array.from({length:2},n=>r.own()),s=[{type:"trace",id:i[0],position:t,width:o.W,voltage:e},{type:"trace",id:i[1],position:t,width:o.W,voltage:gt(e)}],d=s[0],c=[{left_trace:{id:i[0],attach:"right"},right_trace:{id:i[1],attach:"left"},width:o.S}];return{position:t,root:d,conductors:s,spacings:c}},create_left(o,t,e){return this.create_traces(o,t,"positive",e)},create_right(o,t,e){return this.create_traces(o,t,"negative",e)}},"coplanar mirrored pair":{create_traces(o,t,e,r){const i=Array.from({length:4},n=>r.own()),s=[{type:"trace",id:i[0],position:t,width:o.CW,voltage:"ground"},{type:"trace",id:i[1],position:t,width:o.W,voltage:e},{type:"trace",id:i[2],position:t,width:o.W,voltage:gt(e)},{type:"trace",id:i[3],position:t,width:o.CW,voltage:"ground"}],d=s[1],c=[{left_trace:{id:i[0],attach:"right"},right_trace:{id:i[1],attach:"left"},width:o.CS},{left_trace:{id:i[1],attach:"right"},right_trace:{id:i[2],attach:"left"},width:o.S},{left_trace:{id:i[2],attach:"right"},right_trace:{id:i[3],attach:"left"},width:o.CS}];return{position:t,root:d,conductors:s,spacings:c}},create_left(o,t,e){return this.create_traces(o,t,"positive",e)},create_right(o,t,e){return this.create_traces(o,t,"negative",e)}}};export{_e as B,ce as C,he as S,le as a,de as b,Wt as c,pe as d,ue as e,ne as f,It as g};
